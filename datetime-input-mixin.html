<link rel="import" href="../property-mixins/datetime-mixin.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">
<link rel="import" href="../input-picker-pattern/input-shared-style.html">

<script>
  /**
   * Mixin to extend an element for picking date or time to locale formating and hiding certain datetime-properties
   *
   * @appliesMixin DatetimeMixin
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const DatetimeInputMixin = superClass => { // eslint-disable-line no-unused-vars

    return class extends DatetimeMixin(FormElementMixin(superClass)) { // eslint-disable-line no-undef

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          <div id="input">
            ${this.inputTemplate}
          </div>
        `
      }

      static get styleToInclude() {
        return 'input-shared-style';
      }

      static get styleTemplate() {
        return `
          ${super.styleTemplate || ''}
          :host {
            display: inline-flex;
            outline: none;
          }
          :host([disabled]) {
            pointer-events: none;
          }
          #input,
          #input > div {
            display: inline-flex;
            align-items: baseline;
          }
          #input > div {
            padding: var(--input-field-padding, 0.1em);
          }
          #input integer-input {
            --input-color: var(--inner-input-color, currentColor);
            --input-background: var(--inner-input-background, transparent);
            --input-border-width: var(--inner-input-border-width, thin);
            --input-border-color: var(--inner-input-border-color, transparent);
            --input-border-style: var(--inner-input-border-style, dotted);
            --input-padding: var(--inner-input-padding, 0.1em);
            --input-border-radius: var(--inner-input-border-radius, 0.1em);
            --input-focus-color: var(--inner-input-focus-color, currentColor);
            --input-focus-background: var(--inner-input-focus-background, transparent);
            --input-focus-border-color: var(--inner-input-focus-border-color, transparent);
            --input-focus-border-style: var(--inner-input-focus-border-style, dotted);
          }
          #input .reset {
            display: inline-flex;
            -moz-appearance: none;
            -webkit-appearance: none;
            appearance: none;
            align-self: center;
            margin: 0 0.1em;
            cursor: pointer;
            border-width: var(--inner-input-border-width, thin);
            border-style: var(--inner-input-border-style, dotted);
            border-color: var(--inner-input-border-color, transparent);
            box-sizing: content-box;
            order: 2;
            opacity: 0.5;
            color: inherit;
            background: transparent;
            transition: opacity 250ms cubic-bezier(0.6, 1, 0.2, 1);
            height: 1em;
            width: 1em;
            border-radius: 50%;
            padding: 0.15em;
          }
          #input .reset > svg {
            height: 100%;
            width: 100%;
            fill: currentColor;
          }
          #input .reset:hover,
          #input .reset:focus {
            color: var(--input-focus-color, inherit);
            background: var(--inner-input-focus-background, rgba(0,0,0,0.16));
            border-style: var(--inner-input-focus-border-style, dotted);
            border-color: var(--inner-input-focus-border-color, transparent);
            outline: none;
          }
          #input .reset:hover {
            opacity: 1;
          }
          [invisible] {
            visibility: hidden;
          }
        `;
      }

      /**
       * template for the focusable
       * @type {string}
       */
      static get inputTemplate() {
        return '<button class="icon reset" invisible$="[[_resetButtonIsInvisible]]" hidden$="[[disabled]]" on-click="_resetDate"><svg viewBox="0 0 24 24"><g><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></g></svg></button>';
      }

      static get properties() {
        return {

          _resetButtonIsInvisible: {
            type: Boolean,
            computed: '_computeResetButtonIsHidden(_valueIsSet, _defaultValue, value)'
          },

          _defaultValue: {
            type: Number,
            computed: '_computeDefaultValue(default)'
          },

          /**
          * If set the step defines the step a date should be incremented (in seconds). The input for the most inferior standing that would create an integer step is used to increment the value.
          * For example, if the **step** is:
          *  + **0.05**: the millisecond-input will increment the value by 50 (50 milliseconds), the other inputs behaive as expected
          *  + **1.05**: the millisecond-input will increment the value by 1050 (1 second and 50 millisecond), the other inputs behaive as expected
          *  + **2**: the millisecond-input will be disabled, the second-input will increment the value by 2000 (2 seconds), the other inputs behaive as expected
          *  + **180**: the millisecond-input and the second-input will be disabled, the minute-input will increment the value by 180000 (3 minutes), the other inputs behaive as expected
          * If `step="0"` all inputs will be disabled, else if the step is below _0.001_ the step will be set to **0.001**. The most supirior input that will become the given step is the day-input.
           */
          step: {
            type: Number,
            notify: true
          },

          /**
           * date-parts that are hidden
           * e.g. '{ "year": true }' would hide the input for the year
           */
          partsHidden: {
            type: Object,
            value: function() {
              return {};
            },
            notify: true
          },

          /**
           * date-parts that are disabled
           */
          partsDisabled: {
            type: Object,
            notify: true,
            value: function() {
              return {}
            }
          },

          /**
           * the computed steps for the date-parts
           */
          partsStep: {
            type: Object,
            notify: true,
            readOnly: true,
            value: function() {
              return {
                day: 1,
                hour: 1,
                minute: 1,
                second: 1,
                millisecond: 1
              }
            }
          }

        }
      }

      static get observers() {
        return [
          '_computePartsStep(step)',
          '_computePartsDisabled(partsStep.*, disabled)'
        ]
      }

      _computeInvalid(required, value) {
        this.invalid = required && isNaN(value);
      }

      _computePartOrder(first) {
        return first ? 0 : 1;
      }

      _computeDefaultValue(def) {
        if (def !== undefined) {
          const d = this._fromDatetime(def);
          if (!isNaN(d)) {
            return +d;
          }
        }
      }

      _computeResetButtonIsHidden(_valueIsSet, _defaultValue, value) {
        return !_valueIsSet || (_defaultValue !== undefined && _defaultValue === value);
      }

      /**
       * compute the steps for the related inputs. The day-input is the highest modified input allthough if the step is higher than a day in seconds it might also change month- or year-inputs.
       */
      _computePartsStep(step) {
        if (step === undefined) return;

        if (step === 0) {
          this.set('partsStep.day', 0);
          this.set('partsStep.hour', 0);
          this.set('partsStep.minute', 0);
          this.set('partsStep.second', 0);
          this.set('partsStep.millisecond', 0);
          this.notifyPath('partsStep');
          this._computePartsDisabled(this.disabled);
          return;
        } else if (step < 0.001) {
          this.set('step', 0.001);
          this.set('partsStep.day', 1);
          this.set('partsStep.hour', 1);
          this.set('partsStep.minute', 1);
          this.set('partsStep.second', 1);
          this.set('partsStep.millisecond', 1);
          this.notifyPath('partsStep');
          this._computePartsDisabled(this.disabled);
          return;
        }
        step = +step.toFixed(3);

        if (step % 86400 === 0) {
          this.set('partsStep.day', step / 86400);
          this.set('partsStep.hour', 0);
          this.set('partsStep.minute', 0);
          this.set('partsStep.second', 0);
          this.set('partsStep.millisecond', 0);
          if (this._ifClamped(this.clamp, 'day')) {
            // reset `clamp` to next inferior standing if clamped
            this.set('clamp', 'hour');
          }
        } else if (step % 3600 === 0) {
          this.set('partsStep.day', 1);
          this.set('partsStep.hour', step / 3600);
          this.set('partsStep.minute', 0);
          this.set('partsStep.second', 0);
          this.set('partsStep.millisecond', 0);
          if (this._ifClamped(this.clamp, 'hour')) {
            // reset `clamp` to next inferior standing if clamped
            this.set('clamp', 'minute');
          }
        } else if (step % 60 === 0) {
          this.set('partsStep.day', 1);
          this.set('partsStep.hour', 1);
          this.set('partsStep.minute', step / 60);
          this.set('partsStep.second', 0);
          this.set('partsStep.millisecond', 0);
          if (this._ifClamped(this.clamp, 'minute')) {
            // reset `clamp` to next inferior standing if clamped
            this.clamp = second;
          }
        } else if (step % 1 === 0) {
          this.set('partsStep.day', 1);
          this.set('partsStep.hour', 1);
          this.set('partsStep.minute', 1);
          this.set('partsStep.second', step);
          this.set('partsStep.millisecond', 0);
          if (this._ifClamped(this.clamp, 'second')) {
            // reset `clamp` to next inferior standing if clamped
            this.set('clamp', 'millisecond');
          }
        } else {
          this.set('partsStep.day', 1);
          this.set('partsStep.hour', 1);
          this.set('partsStep.minute', 1);
          this.set('partsStep.second', 1);
          this.set('partsStep.millisecond', step * 1000);
          if (this._ifClamped(this.clamp, 'millisecond')) {
            // reset `clamp` to next inferior standing if clamped
            this.set('clamp', '');
          }
        }
        this.notifyPath('partsStep');
        this._computePartsDisabled(this.disabled);
      }

      _computePartsDisabled(change, disabled) {
        if (change === undefined) {
          return;
        }
        const key = 'partsDisabled.' + change.path.split('.')[1];
        if (disabled) {
          this.set(key, true);
        } else if (this.partsStep !== undefined) {
          this.set(key, !change.value);
        }
        this.notifyPath('partsDisabled');
      }
    }
  }
</script>
