<link rel="import" href="../property-mixins/datetime-mixin.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">

<script>
  /**
   * Mixin to extend an element for picking date or time to locale formating and hiding certain datetime-properties
   *
   * @appliesMixin DatetimeMixin
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const DatetimeInputMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends DatetimeMixin(FormElementMixin(superClass)) { // eslint-disable-line no-undef

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.inputTemplate}
        `
      }

      static get styleTemplate() {
        return `
          <style include="${this.customStyleToInclude}">
            ${this.customStyleContent}
          </style>
        `;
      }

      static get customStyleToInclude() {
        return '';
      }

      static get customStyleContent() {
        return `
          ${super.customStyleToInclude || ''}
          :host {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            align-items: baseline;
            outline: none;
            padding: 0.1em 0.2em;
            --input-focus-background: var(--primary-color, rgba(0,0,0,0.2));
            --input-style: {
              border-radius: 2px;
              padding: 0.2em 0.1em;
              cursor: pointer;
              transition: background-color 150ms cubic-bezier(0.6, 1, 0.2, 1);
            };
          }
          [hidden] {
            display: none !important;
          }
        `;
      }

      /**
       * template for the focusable
       * @type {string}
       */
      static get inputTemplate() {
        return '';
      }

      connectedCallback() {
        super.connectedCallback();
        this._ensureAttribute('tabindex', 0);
        this._addKeyListener();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeKeyListener();
      }

      _addKeyListener() {
        if (super._addKeyListener) {
          super._addKeyListener();
        }
        this.addEventListener('keydown', this._checkKeycode.bind(this), false);
      }

      _removeKeyListener() {
        if (super._removeKeyListener) {
          super._removeKeyListener();
        }
        this.removeEventListener('keydown', this._checkKeycode.bind(this), false);
      }

      /**
       * key press event handler
       * @param  {[type]} e Event
       */
      _checkKeycode(e) {
        if (!e) {
          return;
        }
        if (super._checkKeycode) {
          super._checkKeycode(e);
        }
        if (e && e.keyCode) {
          switch (e.keyCode) {
            case 37: // left
              this._focusNumberInput(e, -2);
              e.stopPropagation();
              return;
            case 9: // tab
              e.preventDefault(); // falls through
            case 39: // right
              this._focusNumberInput(e, 2);
              e.stopPropagation();
              return;
          }
        }
      }

      _focusNumberInput(e, step) {
        let currentIndex = -1;
        const path = e.composedPath(); // retargeting fix for certain browsers
        for (let i = 0; i < path.length; i++) {
          if (path[i].getAttribute && path[i].hasAttribute('index')) {
            currentIndex = +path[i].getAttribute('index');
            break;
          }
        }

        let min = 0, max = 0;
        const focusable = Array.prototype.filter.call(this.root.querySelectorAll('[index]'), inp => {
          if (!(inp.hasAttribute('hidden') || (inp.parentElement && inp.parentElement.hasAttribute('hidden')))) {
            let index = +inp.getAttribute('index');
            if (index !== undefined) {
              min = (min && min < index ) ? min : index;
              max = (max && max > index ) ? max : index;
              return true;
            }
          }
          return false;
        });
        if (focusable && focusable.length) {
          focusable.sort( (a, b) => {
            return +a.getAttribute('index') > +b.getAttribute('index')
          })
          let newIndex = currentIndex + step;
          if (newIndex > max) {
            newIndex = min;
          } else if (newIndex < min) {
            newIndex = max;
          }
          if (step > 0) {
            for (let i = 0; i < focusable.length; i++) {
              if (+focusable[i].getAttribute('index') >= newIndex) {
                focusable[i].focus();
                return;
              }
            }
          } else {
            for (let i = focusable.length - 1; i >= 0; i--) {
              if (+focusable[i].getAttribute('index') <= newIndex) {
                focusable[i].focus();
                return;
              }
            }
          }
        }
      }
    }
  }
</script>
