<link rel="import" href="../property-mixins/datetime-mixin.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">
<link rel="import" href="../input-picker-pattern/input-shared-style.html">

<script>
  /**
   * Mixin to extend an element for picking date or time to locale formating and hiding certain datetime-properties
   *
   * @appliesMixin DatetimeMixin
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const DatetimeInputMixin = superClass => { // eslint-disable-line no-unused-vars

    return class extends DatetimeMixin(FormElementMixin(superClass)) { // eslint-disable-line no-undef

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          <div id="input">
            ${this.inputTemplate}
          </div>
        `
      }

      static get styleToInclude() {
        return 'input-shared-style';
      }

      static get styleTemplate() {
        return `
          ${super.styleTemplate || ''}
          :host {
            display: inline-flex;
            outline: none;
          }
          :host([disabled]) {
            pointer-events: none;
          }
          #input,
          #input > div {
            display: inline-flex;
            align-items: baseline;
          }
          #input > div {
            padding: var(--input-field-padding, 0.1em);
          }
          #input integer-input {
            --input-color: var(--inner-input-color, currentColor);
            --input-background: var(--inner-input-background, transparent);
            --input-border-width: var(--inner-input-border-width, thin);
            --input-border-color: var(--inner-input-border-color, transparent);
            --input-border-style: var(--inner-input-border-style, dotted);
            --input-padding: var(--inner-input-padding, 0);
            --input-border-radius: var(--inner-input-border-radius, 0.1em);
            --input-focus-color: var(--inner-input-focus-color, currentColor);
            --input-focus-background: var(--inner-input-focus-background, transparent);
            --input-focus-border-color: var(--inner-input-focus-border-color, transparent);
            --input-focus-border-style: var(--inner-input-focus-border-style, dotted);
          }
          #input .reset {
            display: inline-flex;
            -moz-appearance: none;
            -webkit-appearance: none;
            appearance: none;
            align-self: center;
            margin: 0 0.1em;
            cursor: pointer;
            border-width: var(--inner-input-border-width, thin);
            border-style: var(--inner-input-border-style, dotted);
            border-color: var(--inner-input-border-color, transparent);
            box-sizing: content-box;
            order: 2;
            opacity: 0.5;
            color: inherit;
            background: transparent;
            transition: opacity 250ms cubic-bezier(0.6, 1, 0.2, 1);
            height: 1em;
            width: 1em;
            border-radius: 50%;
            padding: 0.15em;
          }
          #input .reset > svg {
            height: 100%;
            width: 100%;
            fill: currentColor;
          }
          #input .reset:hover,
          #input .reset:focus {
            color: var(--inner-input-focus-color);
            border-color: var(--input-focus-border-color, currentColor);
            outline: none;
          }
          #input .reset:hover {
            background: transparent;
            opacity: 1;
          }
          #input .reset:focus {
            background: var(--inner-input-focus-background, rgba(255,255,255,0.25));
          }
          [invisible] {
            visibility: hidden;
          }
        `;
      }

      /**
       * template for the focusable
       * @type {string}
       */
      static get inputTemplate() {
        return '<button class="icon reset" invisible$="[[_resetButtonIsInvisible]]" hidden$="[[disabled]]" on-click="_resetDate"><svg viewBox="0 0 24 24"><g><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></g></svg></button>';
      }

      static get properties() {
        return {

          _resetButtonIsInvisible: {
            type: Boolean,
            computed: '_computeResetButtonIsHidden(_valueIsSet, _defaultValue, value)'
          },

          _defaultValue: {
            type: Number,
            computed: '_computeDefaultValue(default)'
          },

          /**
          * If set the step defines the step a date should be incremented (in seconds). The input for the most inferior standing that would create an integer step is used to increment the value.
          * For example, if the **step** is:
          *  + **0.05**: the millisecond-input will increment the value by 50 (50 milliseconds), the other inputs behaive as expected
          *  + **1.05**: the millisecond-input will increment the value by 1050 (1 second and 50 millisecond), the other inputs behaive as expected
          *  + **2**: the millisecond-input will be disabled, the second-input will increment the value by 2000 (2 seconds), the other inputs behaive as expected
          *  + **180**: the millisecond-input and the second-input will be disabled, the minute-input will increment the value by 180000 (3 minutes), the other inputs behaive as expected
          * If `step="0"` all inputs will be disabled, else if the step is below _0.001_ the step will be set to **0.001**. The most supirior input that will become the given step is the day-input.
           */
          step: {
            type: Number,
            notify: true
          },

          /**
           * date-parts that are hidden
           * e.g. '{ "year": true }' would hide the input for the year
           */
          partsHidden: {
            type: Object,
            value: function() {
              return {};
            },
            notify: true
          },

          /**
           * date-parts that are disabled
           */
          partsDisabled: {
            type: Object,
            computed: '_computePartsDisabled(partsStep, disabled)',
            notify: true
          },

          /**
           * the computed steps for the date-parts
           */
          partsStep: {
            type: Object,
            computed: '_computePartsStep(step)',
            notify: true
          }

        }
      }

      static get observers() {
        return [
          '_computePartsHidden(clamp)'
        ]
      }

      _computeInvalid(required, value) {
        this.invalid = required && isNaN(value);
      }

      _computePartOrder(first) {
        return first ? 0 : 1;
      }

      _computeDefaultValue(def) {
        if (def !== undefined) {
          const d = this._fromDatetime(def);
          if (!isNaN(d)) {
            return +d;
          }
        }
      }

      _computeResetButtonIsHidden(_valueIsSet, _defaultValue, value) {
        return !_valueIsSet || (_defaultValue !== undefined && _defaultValue === value);
      }

      _computePartsHidden(clamp) {
        let step;
        switch (clamp) {
          case 'year':
            this.set('partsHidden.year', true); // falls through
          case 'month':
            this.set('partsHidden.month', true); // falls through
          case 'day':
            this.set('partsHidden.day', true);
            step = 86400; // falls through
          case 'hour':
            this.set('partsHidden.hour', true);
            step = 3600; // falls through
          case 'minute':
            this.set('partsHidden.minute', true);
            step = 60; // falls through
          case 'second':
            this.set('partsHidden.second', true);
            step = 1; // falls through
          case 'millisecond':
            this.set('partsHidden.millisecond', true);
            step = 0.001; // falls through
            break;
          default:
            if (this.partsHidden.year === undefined)
              this.set('partsHidden.year', false);

            if (this.partsHidden.month === undefined)
              this.set('partsHidden.month', false);

            if (this.partsHidden.day === undefined)
              this.set('partsHidden.day', false);

            if (this.partsHidden.hour === undefined)
              this.set('partsHidden.hour', false);

            if (this.partsHidden.minute === undefined)
              this.set('partsHidden.minute', false);

            if (this.partsHidden.second === undefined)
              this.set('partsHidden.second', false);

            if (this.partsHidden.millisecond === undefined)
              this.set('partsHidden.millisecond', false);
        }
        if (this.step === undefined) {
          this.set('step', step);
        }
      }

      /**
       * compute the steps for the related inputs. The day-input is the highest modified input allthough if the step is higher than a day in seconds it might also change month- or year-inputs.
       */
      _computePartsStep(step) {
        if (step === undefined) return;

        if (step === 0) {
          return {
            day: 0,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          };
        } else if (step < 0.001) {
          this.step = 0.001;
          return {
            day: 1,
            hour: 1,
            minute: 1,
            second: 1,
            millisecond: 0.001
          };
        }
        step = +step.toFixed(3);

        let partsStep = {
          day: 1,
          hour: 1,
          minute: 1,
          second: 1,
          millisecond: 0.001
        };

        if (step % 86400 === 0) {
          partsStep.day = step / 86400;
          partsStep.hour = 0;
          partsStep.minute = 0;
          partsStep.second = 0;
          partsStep.millisecond = 0;
          if (this._ifClamped(this.clamp, 'day')) {
            // reset `clamp` to next inferior standing if clamped
            this.clamp = 'hour';
          }
        } else if (step % 3600 === 0) {
          partsStep.hour = step / 3600;
          partsStep.minute = 0;
          partsStep.second = 0;
          partsStep.millisecond = 0;
          if (this._ifClamped(this.clamp, 'hour')) {
            // reset `clamp` to next inferior standing if clamped
            this.clamp = 'minute';
          }
        } else if (step % 60 === 0) {
          partsStep.minute = step / 60;
          partsStep.second = 0;
          partsStep.millisecond = 0;
          if (this._ifClamped(this.clamp, 'minute')) {
            // reset `clamp` to next inferior standing if clamped
            this.clamp = 'second';
          }
        } else if (step % 1 === 0) {
          partsStep.second = step;
          partsStep.millisecond = 0;
          if (this._ifClamped(this.clamp, 'second')) {
            // reset `clamp` to next inferior standing if clamped
            this.clamp = 'millisecond';
          }
        } else {
          partsStep.millisecond = step;
          if (this._ifClamped(this.clamp, 'millisecond')) {
            // reset `clamp` to next inferior standing if clamped
            this.clamp = '';
          }
        }
        return partsStep;
      }

      _computePartsDisabled(partsStep, disabled) {
        if (!disabled && partsStep === undefined) return;

        if (disabled) {
          return {
            year: true,
            month: true,
            day: true,
            hour: true,
            minute: true,
            second: true,
            millisecond: true
          };
        }
        return {
          year: !partsStep.day,
          month: !partsStep.day,
          day: !partsStep.day,
          hour: !partsStep.hour,
          minute: !partsStep.minute,
          second: !partsStep.second,
          millisecond: !partsStep.millisecond
        };
      }
    }
  }
</script>
