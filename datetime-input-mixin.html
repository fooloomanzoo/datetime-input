<link rel="import" href="../property-mixins/datetime-mixin.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">

<script>
  /**
   * Mixin to extend an element for picking date or time to locale formating and hiding certain datetime-properties
   *
   * @appliesMixin DatetimeMixin
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const DatetimeInputMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends DatetimeMixin(FormElementMixin(superClass)) { // eslint-disable-line no-undef

      static get template() {
        return `
          ${this.styleTemplate}
          <div id="input">
            ${this.inputTemplate}
          </div>
        `
      }

      static get styleTemplate() {
        return `
          <style include="${this.customStyleToInclude}">
            ${this.customStyleContent}
          </style>
        `;
      }

      static get customStyleToInclude() {
        return '';
      }

      static get customStyleContent() {
        return `
          ${super.customStyleToInclude || ''}
          :host {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            outline: none;
          }
          #input {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            align-items: center;
            outline: none;
            padding: 0.1em 0.2em;
            border-radius: 3px;
            border-width: thin;
            border-style: dotted;
            border-color: transparent;
            @apply --input-style;
          }
          #input:hover,
          #input:focus {
            @apply --input-focus;
          }
          :host([invalid]) #input {
            border-width: thin;
            border-style: dotted;
            border-color: var(--input-invalid-color, red);
            @apply --input-invalid;
          }
          #input > div {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            align-items: center;
          }
          #input integer-input {
            --number-input-focus: {
              outline: none;
              color: var(--input-focus-color, inherit);
              background: var(--input-focus-background, rgba(0,0,0,0.1));
              @apply --input-focus;
              border-color: transparent;
            };
            --number-input: {
              border-radius: 2px;
              padding: 0.15em;
              cursor: pointer;
              transition: background 150ms cubic-bezier(0.6, 1, 0.2, 1);
              @apply --input-style;
              border-color: transparent;
            };
            --number-input-placeholder: {
              color: rgba(0,0,0,0.334);
              @apply --input-placeholder;
            };
          }
          #input .icon.reset {
            padding: 2px;
            height: 12px;
            width: 12px;
            align-self: center;
            border-radius: 50%;
            order: 13;
            opacity: 0.5;
            fill: currentColor;
          }
          #input .icon.reset:focus,
          #input .icon.reset:hover {
            opacity: 1;
            @apply --input-focus;
            border-width: 0;
          }
          [hidden] {
            display: none !important;
          }
        `;
      }

      /**
       * template for the focusable
       * @type {string}
       */
      static get inputTemplate() {
        return '<svg class="icon button reset" hidden$="[[!_valueIsSet]]" viewBox="0 0 24 24" on-click="_resetDate"><g><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></g></svg>';
      }

      static get properties() {
        return {

          _valueIsSet: {
            type: Boolean,
            value: false
          }

        }
      }

      static get observers() {
        return [
          '_computeValueIsSet(value)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this._ensureAttribute('tabindex', 0);
        this._addKeyListener();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeKeyListener();
      }

      _computeInvalid(required, value) {
        this.invalid = required && isNaN(value);
      }

      _addKeyListener() {
        if (super._addKeyListener) {
          super._addKeyListener();
        }
        this.addEventListener('keydown', this._checkKeycode.bind(this), false);
      }

      _removeKeyListener() {
        if (super._removeKeyListener) {
          super._removeKeyListener();
        }
        this.removeEventListener('keydown', this._checkKeycode.bind(this), false);
      }

      /**
       * key press event handler
       * @param  {[type]} e Event
       */
      _checkKeycode(e) {
        if (!e) {
          return;
        }
        if (super._checkKeycode) {
          super._checkKeycode(e);
        }
        if (e && e.keyCode) {
          switch (e.keyCode) {
            case 37: // left
              this._focusNumberInput(e, -2);
              e.stopPropagation();
              return;
            case 9: // tab
              e.preventDefault(); // falls through
            case 39: // right
              this._focusNumberInput(e, 2);
              e.stopPropagation();
              return;
          }
        }
      }

      _focusNumberInput(e, step) {
        let currentIndex = -1;
        const path = e.composedPath(); // retargeting fix for certain browsers
        for (let i = 0; i < path.length; i++) {
          if (path[i].getAttribute && path[i].hasAttribute('index')) {
            currentIndex = +path[i].getAttribute('index');
            break;
          }
        }

        let min = 0, max = 0;
        const focusable = Array.prototype.filter.call(this.root.querySelectorAll('[index]'), inp => {
          if (!(inp.hasAttribute('hidden') || (inp.parentElement && inp.parentElement.hasAttribute('hidden')))) {
            let index = +inp.getAttribute('index');
            if (index !== undefined) {
              min = (min && min < index ) ? min : index;
              max = (max && max > index ) ? max : index;
              return true;
            }
          }
          return false;
        });

        if (focusable && focusable.length) {
          focusable.sort( (a, b) => {
            return +a.getAttribute('index') > +b.getAttribute('index')
          })
          let newIndex = currentIndex + step;
          if (newIndex > max) {
            newIndex = min;
          } else if (newIndex < min) {
            newIndex = max;
          }
          if (step > 0) {
            for (let i = 0; i < focusable.length; i++) {
              if (+focusable[i].getAttribute('index') >= newIndex) {
                focusable[i].focus();
                return;
              }
            }
          } else {
            for (let i = focusable.length - 1; i >= 0; i--) {
              if (+focusable[i].getAttribute('index') <= newIndex) {
                focusable[i].focus();
                return;
              }
            }
          }
        }
      }

      _computeValueIsSet(value) {
        this._valueIsSet = value !== undefined;
      }

    }
  }
</script>
